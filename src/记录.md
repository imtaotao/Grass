1. 每个组件只能有一个根节点
2. 组件的根节点不能使用 v-for v-if 指令，但需要 parent 的拒绝
3. 组件的标签上的所有属性都迁移到组件内的根节点上的 props 属性上
4. 组件的标签上的指令就地解析，然后把解析过的属性迁移过去，但是操作自身 children 的指令需要把编译结果迁移到子组件的根节点上，比如 v-text


#### 剩下的需要解决的问题
+ [x] 指令迁移
+ [x] 把普通属性添加为 virtual-dom 支持的格式
+ [x] 在组件标签上的 attrs 转为 props 时的过滤
+ [x] vnode 部分的重写
+ [x] props 稳定性问题
+ [x] 自定义指令的实现
+ [x] 组件之间的通信问题
+ [ ] 暴露的接口设计
+ [x] 对 for 循环专门做一个词法环境的包装
+ [ ] with 语句的改为手动的声明变量
+ [x] 无状态组件

#### 组件指令的迁移
1. v-bind 我们没有什么需要改的，直接添加到 attrs 上，等待作为 props 迁移
2. v-event 我们作为组件通信的 observer 注册函数
3. v-for 我们对当前的组件标签像普通的标签一样进行执行
4. v-if 我们对当前的组件标签像普通的标签一样进行执行
5. v-show 如果确定是组件标签，我们会在当前标签的 nodeConfig 上给加上一个 vShowResult，等待迁移
6. v-text 如果确定是组件标签，我们会在当前标签的 nodeConfig 上给加上一个 vTextResult，等待迁移

### 后续需要考虑的部分
+ webpack loader 的实现
+ 插件的扩展
+ 增加响应式数据和细粒度的 vnode 生成
+ virtual-dom 的 diff 和 patch 换成自己的

### setState 是的逻辑
1. 拿到缓存的 ast，重新编译指令
2. 生成 render 配置对象
3. 创建 vnode
4. diff
5. patch

比起纯 render 函数，多了 1、2 两个步骤，但是能提供额外的模板语法糖